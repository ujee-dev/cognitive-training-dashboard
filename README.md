# 카드 매칭 인지 훈련 & 성과 분석 시스템 (Full-Stack)

기존 로컬 환경의 카드 매칭 게임을 확장하여,
**NestJS와 MongoDB 기반의 JWT 인증 체계**를 도입하고
사용자의 인지 지표를 서버에서 통합 관리하는 풀스택 프로젝트입니다.

단순한 게임 플레이를 넘어,
**사용자의 반응속도와 정확도 데이터를 수집하고 이를 정교한 알고리즘(집중도 점수)으로 분석**하는 것에
초점을 맞추고 있습니다.

---

## 프로젝트 구조 및 기술 스택

현재 프로젝트는 **Monorepo** 구조로 관리되며, 클라이언트와 서버가 독립적인 책임을 가집니다.

### [Frontend] : `client/`

- **핵심 기술**: React, TypeScript, Vite, Tailwind CSS
- **상태/데이터**: Axios (인터셉터 기반 JWT 처리), Recharts (성과 시각화), LocalStorage
- **특징**: 게임 로직과 통계 로직을 분리하여 데이터 측정의 신뢰성 확보

### [Backend] : `server/`

- **핵심 기술**: NestJS, MongoDB (Mongoose), JWT (Passport)
- **데이터베이스**: MongoDB Atlas (Cloud)
- **특징**: RESTful API 설계, 가드(Guard) 기반 보안 통신, 난이도별 랭킹 산출 로직

---

## 주요 업데이트 및 해결 과제

### 1. 보안 인증 체계 도입 (JWT)

- **로그인/회원가입**: 서버 기반 인증을 통해 개인별 맞춤형 성과 데이터 보호
- **Axios 인터셉터**: 요청 헤더에 토큰을 자동으로 주입하여 보안 통신의 일관성 유지
- **유효성 검사**: 서버 수준의 ValidationPipe를 통해 데이터 정밀 검증 (이메일 형식, 비밀번호 강도 등)

### 2. 데이터 아키텍처 개편

- **기존**: `localStorage`에만 의존하여 기기 간 데이터 공유 불가
- **변경**: 서버 API 연동을 통해 **언제 어디서든 본인의 인지 훈련 기록 조회 가능**
- **동기화**: 로그인 성공 시 로컬과 서버의 데이터를 동기화하여 끊김 없는 사용자 경험 제공

### 3. 정교한 인지 지표 측정 (집중도 점수 설계)

- 단순한 '빠르기' 경쟁이 아닌, **정확도(60%) + 반응속도(40%)** 가중치를 적용한 복합 지표 산출
- **미진행 게임(No-play) 필터링**: 클릭 1회 이하 등 의미 없는 데이터를 제외하여 통계 신뢰도 확보

---

## 실행 방법

### 환경 변수 설정

각 폴더(`client`, `server`)에 `.env` 파일을 생성하고 다음 정보를 설정해야 합니다. (실제 값은 유출 주의)

- **Client**: `VITE_APP_API_URL`
- **Server**: `MONGO_URI`, `JWT_SECRET`

### 설치 및 구동

```bash
# 1. Server 실행
cd server
npm install
npm run start:dev

# 2. Client 실행
cd client
npm install
npm run dev

```

---

## 화면 구성 (현재 개발 상태)

### 홈 & 게임 플레이

|                     홈 화면                     |                        게임 대기                        |                     실제 플레이                      |
| :---------------------------------------------: | :-----------------------------------------------------: | :--------------------------------------------------: |
| <img src="./docs/images/home.png" width="180"/> | <img src="./docs/images/game_preview.png" width="180"/> | <img src="./docs/images/game_play.png" width="180"/> |

### 단일 게임 결과

|                          결과 1                          |                          결과 2                          |
| :------------------------------------------------------: | :------------------------------------------------------: |
| <img src="./docs/images/game_result_1.png" width="180"/> | <img src="./docs/images/game_result_2.png" width="180"/> |

### 성과(Performance) 분석

|                        실력 향상 판정                         |                        분석 대시보드 1                        |                        분석 대시보드 2                        |
| :-----------------------------------------------------------: | :-----------------------------------------------------------: | :-----------------------------------------------------------: |
| <img src="./docs/images/game_performance_1.png" width="180"/> | <img src="./docs/images/game_performance_2.png" width="180"/> | <img src="./docs/images/game_performance_3.png" width="180"/> |

### JWT Test (Debug)

- 서버 API 통신 및 인증 상태 실시간 로그 확인 시스템

|                         첫 화면                          |                    로그인 - 기록 조회                    |
| :------------------------------------------------------: | :------------------------------------------------------: |
| <img src="./docs/images/api_jwt_test1.png" width="180"/> | <img src="./docs/images/api_jwt_test2.png" width="180"/> |

---

## 설계 포인트 (Insight)

> "데이터를 관찰하기 위해 게임을 설계하다"

본 프로젝트는 프론트엔드에서 수집된 미세한 사용자 행동(반응 시간)이
백엔드와 DB를 거쳐 어떻게 **신뢰할 수 있는 성과 지표**로 가공되는지에 대한 전 과정을 다룹니다.
특히, **비동기 통신에서의 예외 처리(Try-Catch-As-AxiosError)**와
**타입 안전성(TypeScript)**을 확보하는 데 주력했습니다.

#### \* [FrontEnd] 현재 로직

- 게임 로직과 통계 로직 완전 분리
  - 게임은 측정만, 해석은 성과 화면에서만 수행
  - 단일 게임과 누적 데이터의 책임을 분리
- 파생 데이터는 `useMemo`로 계산
- “유효 게임” 개념 도입으로 통계 신뢰도 확보
- 단일 지표가 아닌 **복합 지표 기반 실력 판단**
- 도구형 서비스 성격에 맞춰 공통 Header를 사용
- 게임 플레이 중에도 현재 위치와 주요 기능 접근성을 유지

---

## Database Schema (MongoDB)

### User Model

- `email`: String (Unique, Indexed)
- `password`: String (Hashed with bcrypt)

### Record Model

- `userId`: ObjectId (Ref: User)
- `difficulty`: String (easy, normal, hard)
- `clearTime`: Number
- `flipCount`: Number
- **`createdAt`**: Date (System generated by Timestamps)

---

### 프로젝트 구조 다이어그램: 전체 흐름

```text
[      Game Screen    ]
          │
          │ (카드 클릭 / 타이머 / 매칭)
          ▼
┌─────────────────────┐
    Game Logic Layer
     (Hooks 중심)

   - 카드 상태 관리
   - 타이머 관리
   - 매칭 판정
   - 정확도 계산
   - 반응 속도 기록
└─────────┬───────────┘
          │
          │ 게임 종료
          ▼
┌─────────────────────┐
      Game Result
      (단일 게임)

   - totalAttempts    : 시도 횟수 (회)
   - correctMatches   : 성공 횟수 (회)
   - failedAttempts   : 실패 횟수 (회)
   - accuracy         : 정확도 (%)
   - avgReactionTime  : 평균 반응 속도 (초)
   - duration         : 플레이 시간 (초)
   - skillScore       : 집중도 (점)
└─────────┬───────────┘
          │ 저장
          ▼
┌─────────────────────┐
     Local Storage
     (Game History)

  StoredGameResult[]
└─────────┬───────────┘
          │ 조회
          ▼
┌─────────────────────┐
    Performance Page
       (성과 분석)

  - 난이도 필터
  - 실력 판정
  - 최근 N회 추이
  - 차트 시각화
  - 평균 비교
  - 최고/최저 반응 속도
└─────────────────────┘
```

---

### 집중도 점수 설계

단순 반응속도는 무작정 빠르게 클릭해도 높아질 수 있습니다.
이를 방지하기 위해 **정확도와 반응속도를 결합한 복합 점수**를 설계했습니다.

- 정확도 비중 ↑
- 반응속도는 보조 지표
- 미진행 게임은 통계에서 제외
- 가중치 상수화로 추후 자동 조정 가능

> “빠르기만 한 플레이”가 아닌
> **정확하고 안정적인 플레이를 높은 점수로 평가**하는 것이 목표입니다.

---

### 집중도 점수 예시 수식 (개념)

- 집중도 (skillScore)

  ```ts
  skillScore = accuracy * ACC_WEIGHT + normalizedReactionTime * REACTION_WEIGHT;
  ```

  - ACC_WEIGHT: 60%
  - REACTION_WEIGHT: 40%

- 정확도 (accuracy): 0 ~ 100

  ```ts
  attempts === 0
    ? 0
    : Math.round((correctMatches / attempts) * (correctMatches / pairs) * 100);
  ```

- reactionTime 정규화 (normalizedReactionTime): 느릴수록 감점
  ```ts
  if (sec <= 0.4) return 100;
  if (sec >= 2.0) return 0;
  return Math.round(100 - ((sec - 0.4) / 1.6) * 100);
  ```

> 현재 가중치는 **실험적 설정**이며,
> 실제 서비스 환경에서는 A/B 테스트를 통해 조정 가능한 구조입니다.

---

### 미진행 게임 제외 이유

#### 문제 상황

- 시간 초과 & 클릭 1회 이하
  > 반응속도 0초로 기록되어 **최고 기록으로 오인**,
  > **집중도** 계산 시 반응속도 가중치가 **40점으로 잘못 적용**됨

#### 해결

- 게임 종료 시 **유효 게임 필터링**하여 저장하지 않음
  ```ts
  avgReactionTime + accuracy > 0;
  ```

➡ 통계 신뢰도 확보

---

### 이동 평균선의 의미

> 개별 게임 결과는 편차가 크기 때문에
> **최근 N(5)회 평균을 연결하여 실질적인 흐름을 파악**하기 위해 사용합니다.

---

### 실력 향상 판정 로직

단순 점수 비교가 아닌,
**데이터 수에 따라 다른 기준을 적용하는 이중 판정 구조**입니다.
판정 결과는 향상 / 저하 / 유지로 구분되며,
수치 변화가 0일 경우 퍼센트 문구는 생략하여 자연스러운 메시지를 제공합니다.

#### 단기 데이터 분석 (2~4개)

- 데이터가 적을 때 발생하는 노이즈 방어
- 첫 기록 대비 마지막 기록 변화율 기준
- 단기 변화율이 ±20% 이상이고 중간 점수가 지나치게 낮지 않을 때만 상태 변화 인정
- 메시지에 변화율이 0%인 경우는 표시하지 않음 → “0% 상승/하락” 어색함 방지

---

#### 장기 추세 분석 (5개 이상)

- 전반부 평균 vs 후반부 평균 비교
- 추세 기반 판정 (`up / down / flat`)
- 최근 평균 점수가 **전체 평균보다 높은지** 추가 확인
- 메시지에 변화율이 있을 경우만 표시, 0% 변화는 생략

➡ 단기 확률적 요인과 장기 안정적 실력 향상을 구분하여,
사용자가 직관적으로 자신의 인지 상태 변화를 이해할 수 있도록 설계되었습니다.

---

## 향후 개선 아이디어

- 대용량 데이터 대비 성능 최적화
- 테스트 코드 추가
- 랭킹/공유/댓글 기능 추가
- 반응속도 **분산(일관성) 지표** 추가
- 게임 도중 헤더를 클릭해 이탈할 경우 현재 진행 중인
  데이터의 유실 처리(자동 패배 처리 vs 기록 제외)에 대한 정책
- 게임 진행 완료율 추가
  - 현재는 100% 진행만 저장
  - 사용자의 중간 이탈 저장 -> 난이도별 이탈율 분석
- 게임 종류 확장 대비 공통 인터페이스 설계

---

## 마무리

이 프로젝트는
**게임을 만들기 위해 데이터를 쓰는 것이 아니라,
데이터를 관찰하기 위해 게임을 만든 사례**입니다.
